#+TITLE: GerbilGSF: Compound File Binary Format

Essentially, my clients use a lot of Microsoft, whereas I stopped using their
products in '96. So, to display them, manipulate them, or even know what they
are, a lexical structuring library is a nice thing to have.


* Installation

** Make sure you have the dynamic library installed

   I use ~Nix~ to install things that are the same across servers and dists.

 #+begin_src shell

   nix search -u gsf
   # * nixpkgs.libgsf (libgsf)
   # GNOME's Structured File Library
   nix-env -iA nixpkgs.libgsf nixpkgs.pkgconfig

 #+end_src

We need to use ~pkg-config~ in order to tell us where things lie. Apparently
that's the way to do it these days.

 #+begin_src shell :session build
   export PKG_CONFIG_PATH=$(nix-shell -p libgsf pkgconfig mount libselinux libsepol \
                              --run 'echo $PKG_CONFIG_PATH')
   # >
   pkg-config --list-all |grep gsf
   # =>
   # libgsf-1  libgsf-1 - A library for reading and writing structured files (eg MS OLE and Zip)

   # >
   pkg-config --cflags --libs libgsf-1
   #-I/nix/store/xj47h03pfszv8nnl0alq5sxld8yjsjyb-libgsf-1.14.46-dev/include/libgsf-1 -I/nix/store/3kg0ihc8k0y7nh3r90hvdsn69k82w4pa-libxml2-2.9.9-dev/include/libxml2 -I/nix/store/fnyy7kwhg8bwxvi2xpjz7vndlz3a1a02-glib-2.62.2-dev/include -I/nix/store/fnyy7kwhg8bwxvi2xpjz7vndlz3a1a02-glib-2.62.2-dev/include/glib-2.0 -I/nix/store/r1qdhsvij69811ysvr0d4ijp1hc9bi94-glib-2.62.2/lib/glib-2.0/include -L/nix/store/82ir1iysw4havqhdpwnxikhmbwkj7g9a-libgsf-1.14.46/lib -L/nix/store/czkcspqabj4b4id26s0xbvd49lhc8l36-libxml2-2.9.9/lib -L/nix/store/r1qdhsvij69811ysvr0d4ijp1hc9bi94-glib-2.62.2/lib -lgsf-1 -lgobject-2.0 -lglib-2.0 -lxml2

 #+end_src
 

** Building this library
 #+begin_src shell :session  (if (get-buffer "build") (if (kill-buffer "build") (print "build") (print "build"))(print "build")) :results output
    echo "reset build session"; true;
 #+end_src

 #+begin_src shell :session build :results output :tangle ./build.sh :shebang "#!/usr/bin/env bash"
   export PKG_CONFIG_PATH=$(nix-shell -p libgsf pkgconfig mount libselinux libsepol \
                              --run 'echo $PKG_CONFIG_PATH')

   compile_gsf () {
   gxc  -cc-options "`pkg-config --cflags libgsf-1`"\
        -ld-options "`pkg-config --libs libgsf-1`" "$1";
    return 0;
   }

   compile_gsf glib.ss;
   compile_gsf infile.ss;
   compile_gsf input.ss;
   compile_gsf gsf.ss;


 #+end_src

 #+RESULTS:

 
 

* Act 1: Read an Outlook ~.msg~ file

  The entire reason for this was to read those files. To start with, one of the
  tests for ~GSF~ is to export a ~msole~ file to a directory tree. Having a
  ~.msg~ file in a directory will help and it's a wonderful first step for FFI,
  so here we go.


** Introduction: The structure of a Message object in the .msg File Format

#+begin_src shell :session build :results output
gcc `pkg-config --cflags --libs libgsf-1` -o test-dump-msole test/test-dump-msole.c 2> /dev/null
./test-dump-msole test/Outlook1.msg test/dump/
#+end_src
 That worked well! But, WTF is it?


 #+begin_quote
 The .msg File Format is based on the Compound File Binary File Format, which is
 described in [fn:MS-CFB]. The paradigm provides for the concept of storages and
 streams, which are similar to directories and files, except that the entire
 hierarchy of storages and streams are packaged into a single file, called a
 compound file. This facility allows applications to store complex, structured
 data in a single file. For more information regarding structured storage in a
 compound file, see [MSDN-STS]"

 #+end_quote

Ok, that helps. The files and directories are streams and storages. What do they
mean?

 #+begin_src shell :results output list
 ls ./test/dump/
 #+end_src

 #+begin_example
 - __attach_version1.0_#00000000
 - __nameid_version1.0
 - __properties_version1.0
 - __recip_version1.0_#00000000
 - __recip_version1.0_#00000001
 - __recip_version1.0_#00000002
 - __recip_version1.0_#00000003
 - __substg1.0_001A001F
 - __substg1.0_002C0102
 - __substg1.0_0037001F
 - __substg1.0_003B0102
 - __substg1.0_003D001F
 - __substg1.0_003F0102
 - __substg1.0_0040001F
 - __substg1.0_00410102
 - __substg1.0_0042001F
 - __substg1.0_00430102
 - __substg1.0_0044001F
 - __substg1.0_00510102
 - __substg1.0_00520102
 - __substg1.0_0064001F
 - __substg1.0_0065001F
 - __substg1.0_0070001F
 - __substg1.0_00710102
 - __substg1.0_0075001F
 - __substg1.0_0076001F
 - __substg1.0_0077001F
 - __substg1.0_0078001F
 - __substg1.0_007D001F
 - __substg1.0_0C190102
 - __substg1.0_0C1A001F
 - __substg1.0_0C1D0102
 - __substg1.0_0C1E001F
 - __substg1.0_0C1F001F
 - __substg1.0_0E02001F
 - __substg1.0_0E03001F
 - __substg1.0_0E04001F
 - __substg1.0_0E05001F
 - __substg1.0_0E1D001F
 - __substg1.0_0F030102
 - __substg1.0_1000001F
 - __substg1.0_10090102
 - __substg1.0_1015001F
 - __substg1.0_1035001F
 - __substg1.0_1039001F
 - __substg1.0_1042001F
 - __substg1.0_300B0102
 - __substg1.0_30140102
 - __substg1.0_3FFA001F
 - __substg1.0_3FFB0102
 - __substg1.0_4022001F
 - __substg1.0_4023001F
 - __substg1.0_4024001F
 - __substg1.0_4025001F
 - __substg1.0_4030001F
 - __substg1.0_4031001F
 - __substg1.0_4034001F
 - __substg1.0_4035001F
 - __substg1.0_4038001F
 - __substg1.0_4039001F
 - __substg1.0_5D01001F
 - __substg1.0_5D02001F
 - __substg1.0_5D07001F
 - __substg1.0_5D08001F
 - __substg1.0_5D0A001F
 - __substg1.0_5D0B001F
 - __substg1.0_65E20102
 - __substg1.0_65E30102
 - __substg1.0_8005001F
 - __substg1.0_8006001F
 - __substg1.0_8007001F
 - __substg1.0_8008001F
 - __substg1.0_8009001F
 - __substg1.0_800A001F
 - __substg1.0_800C0102
 - __substg1.0_800F0048
 - __substg1.0_80100102
 - __substg1.0_8011001F
 - __substg1.0_8012001F
 - __substg1.0_8013001F
 - __substg1.0_8016001F
 - __substg1.0_8018001F
 - __substg1.0_8019001F
 - __substg1.0_801A001F
 - __substg1.0_801B001F
 #+end_example

** Scene 1: Find the ~Subject:~ header
   :PROPERTIES:
   :CUSTOM_ID: find_subject_header
   :END:

   As much as I love reading documentation, I find code to be a better guide.
   Mixing the two in a literate fashion is even better, but I digress.

   I find the [[#msg_reader_js][~msg.reader.js~]] code fairly easy to browse and it has this.

#+begin_src javascript
  FIELD: {
    PREFIX: {
      ATTACHMENT: '__attach_version1.0',
      RECIPIENT: '__recip_version1.0',
      DOCUMENT: '__substg1.'
    },
    NAME_MAPPING: {
      // email specific
      '0037': 'subject'
      // [...]
    }
  }
#+end_src

Cool! So anything child stream whose name starts with ~__substg1.~ is a
~DOCUMENT~? That ~NAME_MAPPING~ also hints towards what I need to know.

If I search the files for that number I get :

 - __substg1.0_0037001F

Ok, what does ~0_~ mean, and ~001F~?

 #+begin_quote
 	The name of that stream is determined by the property's property tag. The
 	stream name is created by prefixing a string containing the hexadecimal
 	representation of the property tag with the string "__substg1.0_". For
 	example, if the property is PidTagScheduleInfoMonthsBusy ([fn:MS-OXPROPS] section
 	2.976), the name of the stream is "__substg1.0_68531003", where "68531003" is
 	the hexadecimal representation of the property tag for
 	PidTagScheduleInfoMonthsBusy.[fn:MS-OXMSG]
#+end_quote

Elsewhere it says "a substorage with the name "__substg1.0_3701000D" MUST be
created.", which helps the ol' noggin process things. ~__substg1.0_~ means a
*substorage*. The rest is a property tag.

Searching for ~001F~ in *MS-OXMSG* gives me 'if the property is PidTagSubject
([fn:MS-OXPROPS] section 2.1027), the name of the stream is
"__substg1.0_0037001F", where "0037001F" is the hexadecimal representation of
the property tag for PidTagSubject'.

Fsck'n A! The code and the docs start to unite. Looking at *MS-OXPROPS* we get a
nice description.


 - Canonical name :: PidTagSubject

 - Description :: Contains the subject of the email message.

 - Property ID :: 0x0037

 - Data type :: PtypString, 0x001F

 - Area :: General Message Properties

 - Defining reference :: *MS-OXCMSG*[fn:MS-OXCMSG] section 2.2.1.46


This feels good. In the defining reference it gives more details

#+begin_quote
Type: PtypString (*MS-OXCDATA*[fn:MS-OXCDATA] section 2.11.1)

The PidTagSubject property ([fn:MS-OXPROPS] section 2.1033) contains the full
subject of an e-mail message. The full subject is a concatenation of the subject
prefix, as identified by the PidTagSubjectPrefix property (section 2.2.1.9), and
the normalized subject, as identified by the PidTagNormalizedSubject property
(section 2.2.1.10). If the PidTagSubjectPrefix property is not set or is set to
an empty string, then the values of the PidTagSubject and
PidTagNormalizedSubject properties are equal.
#+end_quote

Ok ok ok, I'll byte. What is a *PtypString*? 

#+begin_quote
PtypString 0x001F, %x1F.00

Variable size; a string of Unicode characters in UTF-16LE format encoding with
terminating null character (0x0000).

PT_UNICODE, string
#+end_quote

It's a C-string in a certain encoding. We can handle that with a
UTF-16-string[fn:gambc-types] I think. Apparently there's a Byte Order
Mark(*BOM*)[fn:rfc-2781] that lets us know.

I like code. Searching through the git for ~libgsf~[fn:gsf-git] I came across [[*/File
 ~gsf.c~][~gsf.c~]].

It's "a simple archive utility, somewhat similar to tar. It operates on files
following one of the structured file formats understood by the G Structured File
library".

Awesome, so, wait? can that give me the subject?

#+begin_src shell :results code
sh -c 'gsf cat test/Outlook1.msg __substg1.0_0037001F' 
#+end_src

#+RESULTS:
#+begin_src shell
[EXT] Re: [EXT] Re: Outlook .msg files
#+end_src

Ok, this is where it gets fun. When I do so in my terminal emulator, I get a string.

#+begin_src shell
$ gsf cat test/Outlook1.msg __substg1.0_0037001F
[EXT] Re: [EXT] Re: Outlook .msg files
#+end_src

But when I try it in this buffer,  get some weirdness.

#+begin_src shell
[ E X T ]   R e :   [ E X T ]   R e :   O u t l o o k   . m s g   f i l e s 
#+end_src

Ah, wait!! encodings.

#+begin_src shell
gsf cat test/Outlook1.msg __substg1.0_0037001F | iconv --from UTF-16 --to UTF-8 -
#+end_src

: [EXT] Re: [EXT] Re: Outlook .msg files

YAY!! We've now got the code and the knowledge to get it from gerbil. Let's go!

** Scene 2: Gerbil-ize it!

   Here's what I think we need.

   1) Read the file
   2) Find the child named ~__substg1.0_0037001~
   3) Output the value as a string


*** Read the file.

    Again, code! ~gsf.c~ has ~open_archive~ which does what we want.

    It has a type to declare.


#+begin_src c :noweb-ref open_archive_c
static GsfInfile *
open_archive (char const *filename)
{
  GsfInfile *infile;
  GError *error = NULL;
  GsfInput *src;
  char *display_name;

  src = gsf_input_stdio_new (filename, &error);
  if (error) {
    display_name = g_filename_display_name (filename);
    g_printerr (_("%s: Failed to open %s: %s\n"),
          g_get_prgname (),
          display_name,
          error->message);
    g_free (display_name);
    return NULL;
  }

  infile = gsf_infile_zip_new (src, NULL);
  if (infile) {
    g_object_unref (src);
    return infile;
  }

  infile = gsf_infile_msole_new (src, NULL);
  if (infile) {
    g_object_unref (src);
    return infile;
  }

  infile = gsf_infile_tar_new (src, NULL);
  if (infile) {
    g_object_unref (src);
    return infile;
  }

  display_name = g_filename_display_name (filename);
  g_printerr (_("%s: Failed to recognize %s as an archive\n"),
        g_get_prgname (),
        display_name);
  g_free (display_name);

  g_object_unref (src);
  return NULL;
}
#+end_src
Here's the hierarchy from *Infile reading structed files*[fn:gfs-infile].

Object Hierarchy
    GObject
    ╰── GsfInput
        ╰── GsfInfile
            ├── GsfInfileMSOle
            ├── GsfInfileStdio
            ├── GsfInfileTar
            ├── GsfInfileZip
            ╰── GsfStructuredBlob

We can use that and a ~c-lambda()~[fn:gambc-c-lambda].

#+begin_src gerbil :noweb-ref open-archive-objects
    (define-c-GObject GsfInput (GsfInfile))
    (define-c-GObject GsfInfile (GsfInput))
#+end_src

#+begin_src gerbil :noweb-ref open-archive
 (define open-archive (c-lambda (char-string) GsfInfile* "open_archive"))
#+end_src

That with some includes give as a [[#file_open_archive_ss][file]], which we compile.


 #+begin_src shell :sh :session build :results output
   export PKG_CONFIG_PATH=$(nix-shell -p libgsf pkgconfig mount libselinux libsepol \
                              --run 'echo $PKG_CONFIG_PATH')
   gxc -cc-options "`pkg-config --cflags libgsf-1`" -ld-options "`pkg-config --libs libgsf-1`" test/open-archive.ss
 #+end_src

Now we can read the file.

#+begin_src gerbil
  (import :drewc/gsf/test/open-archive)

  (open-archive "/home/user/src/gerbil-gsf/test/Outlook1.msg")
  ;; => #<GsfInfile* #133 0xf922b0>
#+end_src

*** Find the child

    ~gsf.c~ has ~find_member~ which is also exactly what we want.

#+begin_src c :noweb-ref find_member_c
static GsfInput *
find_member (GsfInfile *arch, char const *name)
{
  char const *slash = strchr (name, '/');

  if (slash) {
    char *dirname = g_strndup (name, slash - name);
    GsfInput *member;
    GsfInfile *dir;

    member = gsf_infile_child_by_name (arch, dirname);
    g_free (dirname);
    if (!member)
      return NULL;
    dir = GSF_INFILE (member);
    member = find_member (dir, slash + 1);
    g_object_unref (dir);
    return member;
  } else {
    return gsf_infile_child_by_name (arch, name);
  }
}
#+end_src

#+begin_src gerbil :noweb-ref find-member
 (define find-member (c-lambda (GsfInfile* char-string) GsfInput* "find_member"))
#+end_src

*** Output the value as a string

    In ~gsf.c~ there's ~gsf_dump~, which is not quite what we want but leads us
    to a place that does. In [[#file_test_dump_msole_c][~test-dump-msole.c~]] there's a ~_clone~ function
    which leads us to ~gsf_input_read()~[fn:gfs_input_read].

    We'll make a function in C which returns a pointer to a string.

#+begin_src c :noweb-ref __GsfInput_to_string
  static char *
    __GsfInput_to_string (GsfInput *input)
    {
      guint8  const *data;
      size_t len;
      GString *str;
      char *ret;

      len = gsf_input_size (input);

      if (NULL == (data = gsf_input_read (input, len, NULL))) {
        g_warning ("error reading ?");
        return;
      }
      gsf_input_seek (input, 0, G_SEEK_SET); 

      str = g_string_new_len (data, len);

      ret = str->str;

      g_string_free(str, FALSE);

      return ret;
    }
#+end_src


#+begin_src gerbil :noweb-ref input-to-string
  (define input->string (c-lambda (GsfInput*) UTF-16-string "__GsfInput_to_string"))
#+end_src


*** /File/ ~input-to-string.ss~
    :PROPERTIES:
    :CUSTOM_ID: file_find_member_ss
    :END:

#+begin_src gerbil :noweb yes :tangle test/input-to-string.ss
  (import (for-syntax :drewc/gsf/glib) :std/foreign :drewc/gsf/glib)
  (export input->string)

  (begin-glib-ffi (input->string)

    (c-declare #<<END-C


  #include <gsf/gsf.h>
  #include <glib/gi18n.h>
  #include <glib/gstdio.h>
  #include <gio/gio.h>
  #include <locale.h>
  #include <string.h>
  #include <errno.h>

  <<__GsfInput_to_string>>
  END-C
  )
  <<open-archive-objects>>
  <<input-to-string>>)
#+end_src



 #+begin_src shell :results output
   export PKG_CONFIG_PATH=$(nix-shell -p libgsf pkgconfig mount libselinux libsepol \
                                      --run 'echo $PKG_CONFIG_PATH')
   gxc  -cc-options "`pkg-config --cflags libgsf-1`"\
        -ld-options "`pkg-config --libs libgsf-1`"\
        test/input-to-string.ss

   true;
 #+end_src

 #+RESULTS:

And test it.

#+begin_src gerbil
  (import :drewc/gsf/test/input-to-string :drewc/gsf/test/find-member :drewc/gsf/test/open-archive)

  (input->string
   (find-member (open-archive "/home/user/src/gerbil-gsf/test/Outlook1.msg")
               "__substg1.0_0037001F"))
  ;; => #<GsfInput* #135 0xf92230>
#+end_src




*** /File/ ~find-member.ss~
    :PROPERTIES:
    :CUSTOM_ID: file_find_member_ss
    :END:

#+begin_src gerbil :noweb yes :tangle test/find-member.ss
  (import (for-syntax :drewc/gsf/glib) :std/foreign :drewc/gsf/glib)
  (export find-member)

  (begin-glib-ffi (find-member)

    (c-declare #<<END-C


  #include <gsf/gsf.h>
  #include <glib/gi18n.h>
  #include <glib/gstdio.h>
  #include <gio/gio.h>
  #include <locale.h>
  #include <string.h>
  #include <errno.h>

  <<find_member_c>>
  END-C
  )
  <<open-archive-objects>>
  <<find-member>>)
#+end_src


 #+begin_src shell :results output
   export PKG_CONFIG_PATH=$(nix-shell -p libgsf pkgconfig mount libselinux libsepol \
                              --run 'echo $PKG_CONFIG_PATH')
 gxc  -cc-options "`pkg-config --cflags libgsf-1`"\
      -ld-options "`pkg-config --libs libgsf-1`"\
  test/find-member.ss
 #+end_src

 #+RESULTS:

And test it.

#+begin_src gerbil
  (import :drewc/gsf/test/find-member :drewc/gsf/test/open-archive)

  (find-member (open-archive "/home/user/src/gerbil-gsf/test/Outlook1.msg")
               "__substg1.0_0037001F")
  ;; => #<GsfInput* #135 0xf92230>
#+end_src




*** /File/ ~open-archive.ss~
    :PROPERTIES:
    :CUSTOM_ID: file_open_archive_ss
    :END:

#+begin_src gerbil :noweb yes :tangle test/open-archive.ss
  (import (for-syntax :drewc/gsf/glib) :std/foreign :drewc/gsf/glib)
  (export open-archive)

  (begin-glib-ffi (open-archive)

    (c-declare #<<END-C


  #include <gsf/gsf.h>
  #include <glib/gi18n.h>
  #include <glib/gstdio.h>
  #include <gio/gio.h>
  #include <locale.h>
  #include <string.h>
  #include <errno.h>

  <<open_archive_c>>
  END-C
  )
  <<open-archive-objects>>
  <<open-archive>>)
#+end_src



 #+begin_src shell :session build
 gxc  -cc-options "`pkg-config --cflags libgsf-1`"\
      -ld-options "`pkg-config --libs libgsf-1`"\
  test/open-archive.ss
 #+end_src

 #+RESULTS:






** Scene 3:  Exchange properties: MS-OXPROPS documents

 It turn out the name of a child that starts with *__substgis* an Exchange
 property. *Jmcleodfoss/ms-oxprops-db*[fn:github-ms-oxprops] has a wonderful way
 to grab them all in a .csv. We'll make a database with that csv and look it up
 to decode them.

*** The CSV file 

    ~.csv~'s are quite simple and used all the time. Here are the columns.

   1) Canonical Name
   2) ID / LID
   3) Data Type Name
   4) Data Type Code
   5) Property Set Name
   6) Property Set GUID
   7) Property Name
   8) Alternate Name(s)
   9) Area
   10) Defining Reference(s)
   11) Consuming Reference(s)
   12) WebDAV
   13) Description
   14) Version

  The easy way to name things and access them that way is simply to meta-make a
  struct that holds them. The simple reason for doing it this way is I don't
  feel like naming all the fields I don't need.

#+begin_example
(make-struct-type id super fields name plist ctor [field-names = #f]) -> type-descriptor

  id          := symbol; the type id
  super       := type-descriptor or #f; the struct type to inherit from
  fields      := fixnum; number of (new) fields in the type
  name        := symbol; the (displayed) type name
  plist       := alist; type properties
  ctor        := symbol or #f; id of constructor method
  field-names := list of symbols or #f; (displayed) field names

plist elements:
 (transparent: . boolean) ; controls whether the object is transparent
                            in equality and printing
 (final: . boolean)       ; controls whether the class if final
 (print: field ...)       ; printable field names
 (equal: field ...)       ; equality comparable field names

 -- https://cons.io/reference/core-builtin.html#make-struct-type
#+end_example

  #+begin_src gerbil :noweb-ref ms-oxprop-csv

    (def ms-oxprop-csv::type (make-struct-type 'ms-oxprop-csv #f 14 'ms-oxprop-csv [] #f #f))

    (def (ms-oxprop-csv . fields)
      (apply make-struct-instance ms-oxprop-csv::type fields))
  #+end_src

Now we can open the CSV and read a struct.

#+begin_src gerbil
  (def test-line (with-input-from-file "var/ms-oxprops-2020-05-25.csv"
                   (lambda () (read-line) (read-csv-line
                                      (current-input-port)))))

  (def test-struct (apply ms-oxprop-csv test-line))
#+end_src


I only want access to 5 fields.

#+begin_src gerbil :noweb-ref mx-oxprop-csv-fields
  (def ms-oxprop-csv-name (make-struct-field-accessor ms-oxprop-csv::type 0))
  (def ms-oxprop-csv-id (make-struct-field-accessor ms-oxprop-csv::type 1))
  (def ms-oxprop-csv-type-name (make-struct-field-accessor ms-oxprop-csv::type 2))
  (def ms-oxprop-csv-type-id (make-struct-field-accessor ms-oxprop-csv::type 3))
  (def ms-oxprop-csv-area (make-struct-field-accessor ms-oxprop-csv::type 8))
#+end_src

For a key in the db and cache we'll take the id and type-id and put them
together.

#+begin_src gerbil :noweb-ref ms-oxprop-csv-key
  (def (ms-oxprop-csv-key prop (type-only? #f))
    (let* ((id (ms-oxprop-csv-id prop))
           (tid (ms-oxprop-csv-type-id prop))
           (tdrop (if (equal? tid "") tid (string-drop tid 2)))
           (key (string-append (if (equal? id "") id (string-drop id 2))
                               tdrop)))
      (if (equal? key "") #f (if type-only? tdrop key))))
#+end_src

*** LMBD for properties

Now for a little bit of ~lmdb~.

  #+begin_src gerbil :tangle test/lmdb.ss
    (import :std/db/lmdb :std/sugar )
    (export (import: :std/db/lmdb) lmdb-env call-with-transaction)

    (def lmdb-env (lmdb-open "ms-oxprops"))

    (def (call-with-transaction fn)
      (let (txn (lmdb-txn-begin lmdb-env))
        (try
         (begin0 (fn txn)
           (lmdb-txn-commit txn))
         (catch (e) (lmdb-txn-abort txn)
                (displayln (error-message e))
                (raise e)))))
  #+end_src

#+begin_src shell :results values code :session build
compile test/lmdb.ss
#+end_src

Now the csv.

*** The ms-oxprop-db

#+begin_src gerbil :tangle test/ms-oxprop-db.ss :noweb yes
  (import :std/sugar :std/text/csv :std/srfi/13 :drewc/gsf/test/lmdb)
  (export #t)

  <<ms-oxprop-csv>>

  <<mx-oxprop-csv-fields>>

  <<ms-oxprop-csv-key>>

  (def ms-oxprop-db (lmdb-open-db lmdb-env "ms-oxprop"))

  (defstruct ms-oxprop
    (name id type type-id area) transparent: #t)


  (def (ms-oxprop-db-put! txn csv-line)
    (let* ((csv (apply ms-oxprop-csv csv-line))
           (prop (list
                  (string->symbol (ms-oxprop-csv-name csv))
                  (ms-oxprop-csv-id csv)
                  (string->symbol (ms-oxprop-csv-type-name csv))
                  (ms-oxprop-csv-type-id csv)
                  (ms-oxprop-csv-area csv)))
           (key (ms-oxprop-csv-key csv))
           (type-key (ms-oxprop-csv-key csv #t))
           (val (with-output-to-string "" (cut write prop))))
      (when (string? key)
        (if (< 0 (string-length type-key))
          (lmdb-put txn ms-oxprop-db type-key (ms-oxprop-csv-type-name csv)))
        (try
         (lmdb-put txn ms-oxprop-db key val)
         (catch (e)
           (displayln "Error: " (error-message e) key val)
           (error "Error: " (error-message e) key val))))))

  (def (ms-oxprop-db-get txn key)
    (let (v (lmdb-get txn ms-oxprop-db key))
      (if (not v) #f
          (let (v (with-input-from-u8vector v read))
            (if (pair? v)
              (apply make-ms-oxprop v)
              v)))))


  (def (upsert-oxprops (csv "var/ms-oxprops-2020-05-25.csv"))
    (call-with-input-file csv
      (lambda (port) (read-line port)
         (call-with-transaction
          (lambda (txn)
            (let up ((line (read-csv-line port)))
              (if (null? line) (eof-object)
                  (begin (ms-oxprop-db-put! txn line)
                         (up (read-csv-line port))))))))))
#+end_src


#+begin_src shell :results values code :session build
compile test/ms-oxprop-db.ss
#+end_src


*** A list of children

This one is quite easy. ~gsf_infile_num_children~ and
~gsf_infile_child_by_index~[fn:GsfInfile] can do that.

So let's make them lambdas.

#+begin_src gerbil :noweb-ref infile-num-children-and-child-by-index
  (define infile-num-children
    (c-lambda (GsfInfile*) int "gsf_infile_num_children"))
  (define infile-child-by-index
    (c-lambda (GsfInfile* int) GsfInput* "gsf_infile_child_by_index"))
#+end_src

Now make a list from that.


#+begin_src gerbil :noweb-ref infile-children
  (def (infile-children inf)
    (let (num (infile-num-children inf))
      (cond ((= num -1) #f)
            ((= num 0) [])
            (else
             (let infc ((n 0))
               (cons (infile-child-by-index inf n)
                     (if (= (1- num) n) []
                         (infc (+ 1 n)))))))))
#+end_src

*** The ~ms-oxprop~ of a ~__substg~ and ~input-value~

    All ~GsfInput~'s have a name it seems, and ~gsf_input_name~[fn:gsf-infile]
    Gives us the name to lookup.


If the name starts with ~__substg~ it is, so to speak, a header. In defined
reality it's a substorage.

#+begin_src gerbil :noweb-ref input-substg?
  (def (input-substg? input)
    (string-prefix? "__substg" (input-name input)))
#+end_src

Everything after the last ~#\_~ is the key.

#+begin_src gerbil :noweb-ref input-ms-oxprop-key
  (def (input-ms-oxprop-key input)
    (let (name (input-name input))
      (try (substring/shared name (1+ (string-index-right name #\_)))
           (catch (_) name))))
#+end_src

Strangely enough even though our database contains a tonne of items, in the
first test there no matching values for some keys. So we backed up and added a
type to the db.

#+begin_src gerbil :noweb-ref input-ms-oxprop
  (def (input-ms-oxprop input)
    (let* ((key (input-ms-oxprop-key input))
           (val (when key (call-with-transaction (cut ms-oxprop-db-get <> key)))))
      (or val
          ;; We don't have anything. Let's make a new one.
          (let* ((key (when key (string-take-right key 4)))
                 (val (when key (call-with-transaction (cut ms-oxprop-db-get <> key))))
                 (name (input-name input)))
            (make-ms-oxprop name #f val (string-append "0x" key) "Unknown")))))
#+end_src


#+begin_src gerbil :noweb-ref substg-value-as-string
  (def (substg-value-as-string input)
    (and (input-substg? input)
         (let* ((oxprop (input-ms-oxprop input))
                (ptype (ms-oxprop-type oxprop)))
           (case ptype
             ((PtypString) (input->string input))
             (else (void))))))


#+end_src


*** /File/ ~test/substg-string.ss~
#+begin_src gerbil :noweb yes :tangle test/substg-string.ss
   (import :std/sugar :std/text/csv :std/srfi/13
           :drewc/gsf/test/lmdb :drewc/gsf/test/ms-oxprop-db
           :drewc/gsf/test/input-to-string :drewc/gsf/test/list-children)
   (export substg-value-as-string input-substg? input-ms-oxprop-key input-ms-oxprop)
   <<input-substg?>>
   <<input-ms-oxprop-key>>
   <<input-ms-oxprop>>
   <<substg-value-as-string>>

#+end_src

*** /File/ ~test/list-children.ss~
#+begin_src gerbil :noweb yes :tangle test/list-children.ss
  (import (for-syntax :drewc/gsf/glib) :std/foreign :drewc/gsf/glib)
  (export infile-children infile-num-children infile-child-by-index input-name)

  (begin-glib-ffi (infile-num-children infile-child-by-index input-name)

    (c-declare #<<END-C


  #include <gsf/gsf.h>
  #include <glib/gi18n.h>
  #include <glib/gstdio.h>
  #include <gio/gio.h>
  #include <locale.h>
  #include <string.h>
  #include <errno.h>
  END-C
  ) 

    <<open-archive-objects>>
    (define input-name (c-lambda (GsfInput*) UTF-8-string "gsf_input_name"))
    <<infile-num-children-and-child-by-index>>
  )
  <<infile-children>>
#+end_src


** Scene 4: Convert UTF-16LE with carriage returns to UTF-8 /sans CR/

   Ok, so we have a string, but it really doesn't work in gerbil. First off, DOS
   line breaks are a PITA, and because it is LE and though I said BOM, blah blah
   blah, it still seems messed up.

   Also, we don't ~free()~ it, so eating memory.

   So, best to covert it using C, which GSF does, and change the C string to Scheme, then free the

 - GObject
   - GsfInput
   - GsfOutput
     - GsfOutputMemory
     - GsfOutputIconv

#+begin_src gerbil :noweb-ref test-iconv-objects
    (define-c-GObject GsfInput #f)
#+end_src
*** /C function/ substg_to_utf8_string

#+begin_src c :noweb-ref substg_to_utf8_string
  static const char *
  substg_to_utf8_string (GsfInput *input)
  {
    guint8  const *data;
    GsfOutput *iconv, *master;
    size_t len;
    GString *str;
    char *ret;

    master = gsf_output_memory_new ();

    iconv = gsf_output_iconv_new (master, "UTF-8", "UTF-16LE");

    if (!gsf_input_copy (input, iconv)) {
      g_warning ("error reading ?");
      return;
    }

    gsf_input_seek (input, 0, G_SEEK_SET);
    gsf_output_close(iconv);
    gsf_output_close(master);

    len = gsf_output_size(master);
    data = gsf_output_memory_get_bytes (GSF_OUTPUT_MEMORY(master));
    str = g_string_new_len (data, len);

    ret = g_string_free(str, FALSE);

    return ret;
  }

  static void* _identity_ (void* i)
   { return i; };
#+end_src

*** /C and Scheme Functions/ ~substg->string~ /et al/

    The idea is simple. Convert to a ~scheme-object~ and ~g_free()~ the string.

    Give us what we need from C.

#+begin_src gerbil :noweb-ref substg-to-char
  (define substg->char* (c-lambda (GsfInput*) (pointer char #f) "____return((char*)substg_to_utf8_string(____arg1));"))
  (define char*->string (c-lambda ((pointer char)) UTF-8-string "___return((char *) ___arg1);"))
  (define g-free (c-lambda ((pointer void)) void "g_free"))

#+end_src

And the gerbil side.

#+begin_src gerbil :noweb-ref substg->string
  (def (substg->string input)
    (let* ((char* (substg->char* input))
           (str (char*->string char*)))
      (begin0 (string-delete (cut char=? <> #\return) str) (g-free char*))))
#+end_src

*** Test it out
#+begin_src gerbil
  (import :drewc/gsf/test/find-member
          :drewc/gsf/test/open-archive
          :drewc/gsf/test/iconv
          :drewc/gsf/test/ms-oxprop-db
          :drewc/gsf/test/list-children
          :drewc/gsf/test/substg-string
          :std/test)

  (def msg (open-archive "/home/user/src/gerbil-gsf/test/Outlook1.msg"))

  [MS-OXBBODY]: Best Body Retrieval Algorithm

  https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxbbody/98296160-746e-4b25-8d45-676dabebb57d

  (def body (find-member msg "__substg1.0_1000001F"))

  (check (input-size body) => 6056)

  (def body-string (substg->string body))

  (check (string-length body-string) => 2952)

  (def attachment (find-member msg "__attach_version1.0_#00000000"))

  ;; ("__substg1.0_37010102" . #<ms-oxprop #130 name: PidTagAttachDataBinary
  ;; id: "0x3701" type: PtypBinary type-id: "0x0102" area: "Message Attachment
  ;; Properties">)
  (def attachment-binary (find-member attachment "__substg1.0_37010102"))
  ;; (def body-rtf (find-member msg "__substg1.0_10090102"))

  ;; (check (ms-oxprop-name (input-ms-oxprop body-rtf))
  ;;        => 'PidTagRtfCompressed)
  ;; (check (ms-oxprop-type (input-ms-oxprop body-rtf))
  ;;        => 'PtypBinary)

  ;; All raw byte sequences are encoded by a length value followed by the specified
  ;; number of bytes. The length value is encoded as a PtypInteger32 ([MS-OXCDATA]
  ;; section 2.11.1) as shown in section 2.9.6.1. For example, the byte sequence 0x22
  ;; 0xF8 0xFF 0x00 0x22 would be encoded as 0x05 0x22 0xF8 0xFF 0x00 0x22. A zero
  ;; length PtypBinary ([MS-OXCDATA] section 2.11.1) value MUST NOT be encoded, but
  ;; MUST be marked as not present in the presenceBitArray.

  ;; (def (bytes->integer bytes)
  ;;   (let lp ((i 0) (r 0))
  ;;     (if (fx< i (u8vector-length bytes))
  ;;       (let (b (u8vector-ref bytes i))
  ;;         (lp (fx1+ i) (bitwise-ior (arithmetic-shift r 8) b)))
  ;;       r)))

  ;; (def (integer->bytes x)
  ;;   (let lp ((x x) (r []))
  ;;     (if (positive? x)
  ;;       (lp (arithmetic-shift x -8)
  ;;           (cons (bitwise-and x #xff) r))
  ;;       (list->u8vector r))))
#+end_src

*** /File/ ~test/iconv.ss~

#+begin_src gerbil :tangle test/iconv.ss :noweb yes
  (import (for-syntax :drewc/gsf/glib) :std/foreign
          :drewc/gsf/glib :std/srfi/13)
  (export substg->string substg-test substg->char* char*->string input-size)

  (begin-glib-ffi (substg->char* char*->string g-free substg-test input-size)

    (c-declare #<<END-C


  #include <gsf/gsf.h>
  #include <glib/gi18n.h>
  #include <glib/gstdio.h>
  #include <gio/gio.h>
  #include <locale.h>
  #include <string.h>
  #include <errno.h>

  <<substg_to_utf8_string>>


  END-C
  )

  <<test-iconv-objects>>
  <<substg-to-char>>

  (define input-size (c-lambda (GsfInput*) size_t "gsf_input_size"))
   <<substg->string>>
#+end_src

#+begin_src gerbil :noweb-ref input-size-read-seek
  (define input-read (c-lambda (GsfInput* size_t) (pointer char) "gsf_input_read(___arg1, ___arg2, NULL);"))
  (define input-seek (c-lambda (GsfInput* size_t) bool
                          "gsf_input_seek(___arg1, ___arg2, G_SEEK_SET);"))

  (define test-read (c-lambda (GsfInput*) UTF-8-string "GsfTestRead"))

#+end_src

** Scene 5: Make attachments into files

 We've almost got the whole message extracted. But we do so in memory. For email
 messages, currently, that is not a terrible idea. For attachments it most
 certainly is a *BAD IDEA*!.


*** Make u8vector

This one seems pretty easy.

  1) Make a ~c-define~ function ~write_u8(guint8, scheme-port)~ which does just that.
  2) Make a C function ~scm_read_bytes_from_input(GsfInput*, num, scheme-port)~ which calls that.
  3) Make scheme function ~read-bytes-from-input(GsfInput* (size #f))~
  4) FFI to ~gsf_input_seek~ and ~gsf_input_tell~ called ~input-byte-position(GsfInput*)~


**** ~write_u8~
  #+begin_src gerbil :noweb-ref write_u8
    (c-define (write-unsigned-int8 int port) (unsigned-int8 scheme-object)
              void "write_u8" "static"
     (write-u8 int port)
     #f)
  #+end_src

**** ~scm_read_bytes_from_input~

 #+begin_src c :noweb-ref scm_read_bytes_from_input
   guint64 scm_read_bytes_from_input(GsfInput *input, size_t n,  ___SCMOBJ port) {

       guint8 const *data;
       guint64 count = 0;
       size_t i;
       gsf_off_t start_offset, remaining;

       start_offset = gsf_input_tell (input);
       remaining = gsf_input_remaining (input);

       n = (n > remaining) ? remaining : n;

       if (NULL == (data = gsf_input_read (input, n, NULL))) {
         g_warning("Error reading from input: gsf_input_read = NULL");
         gsf_input_read (input, 0, NULL);
         gsf_input_seek (input, start_offset, G_SEEK_SET);
         return 0;
       }

       for (i = 0; i < n; ++i) {
         write_u8 (*(data + i), port);
         count++;
       }

       gsf_input_read (input, 0, NULL);
       return count;
   }
 #+end_src

**** ~read-bytes-from-input~
 #+begin_src gerbil :noweb-ref read-bytes-from-input
   (define read-bytes-from-input
     (c-lambda (GsfInput* size_t scheme-object) unsigned-int64
               "scm_read_bytes_from_input"))
 #+end_src


**** ~input-tell~ and ~input-seek~ with ~G_SEEK_[*]~
b
 #+begin_src gerbil :noweb-ref input-tell-and-seek
   (define input-tell (c-lambda (GsfInput*) unsigned-int64 "gsf_input_tell"))

   (define input-seek
     (c-lambda (GsfInput* size_t int) bool
               "gsf_input_seek"))

   ;; https://developer.gnome.org/glib/2.62/glib-IO-Channels.html#GSeekType
   ;; enum GSeekType
   ;; An enumeration specifying the base position for a g_io_channel_seek_position() operation.

   ;; Members
   ;; G_SEEK_CUR the current position in the file.
   ;; G_SEEK_SET the start of the file.
   ;; G_SEEK_END the end of the file.

   (define-const G_SEEK_CUR)
   (define-const G_SEEK_SET)
   (define-const G_SEEK_END)
 #+end_src

**** ~input-byte-position~

 #+begin_src gerbil :noweb-ref input-byte-position

   ;; When called with a single argument these procedures return the byte position
   ;; where the next I/O operation would take place in the file attached to the
   ;; given port (relative to the beginning of the file).

   ;; When called with two or three arguments, the byte position for subsequent I/O
   ;; operations on the given port is changed to position, which must be an exact
   ;; integer.

   ;; When whence is omitted or is 0, the position is relative to the beginning of
   ;; the file.

   ;; When whence is 1, the position is relative to the current byte position of
   ;; the file.

   ;; When whence is 2, the position is relative to the end of the file. The return
   ;; value is the new byte position.

   ;; On most operating systems the byte position for reading and writing of a
   ;; given bidirectional port are the same. -

   ;; --http://www.iro.umontreal.ca/~gambit/doc/gambit.html#I_002fO-and-ports

   (def (input-byte-position input (position #f) (whence #f))
     (def whence-alist `((0 . ,G_SEEK_SET)
                         (1 . ,G_SEEK_CURR)
                         (2 . ,G_SEEK_END)))
     (let (whence (if (not whence) G_SEEK_SET (assget whence-alist whence)))
       (if (not position) (input-tell input)
           (begin (input-seek input position whence)
                  (input-tell input)))))
 #+end_src

**** Test it out
 #+begin_src gerbil
   (import :drewc/gsf/test/find-member
           :drewc/gsf/test/open-archive
           :drewc/gsf/test/iconv
           :drewc/gsf/test/ms-oxprop-db
           :drewc/gsf/test/list-children
           :drewc/gsf/test/substg-string
           :drewc/gsf/test/u8vector
           :drewc/gsf/test/input-to-string
           :std/test

           :std/srfi/13
           :std/text/utf16
           )

   (def msg (open-archive "/home/user/src/gerbil-gsf/test/Outlook1.msg"))

   (def body (find-member msg "__substg1.0_1000001F"))

   (check (input-size body) => 6056)

   (def body-string (substg->string body))

   (check (string-length body-string) => 2952)
   (check (substring body-string 0 10) => "Thank you!")

   (def (test-read-utf16le-string (inp body) (str "Thank you!"))
     (def p (open-output-u8vector))

     (read-bytes-from-input inp (* 2 (string-length str)) p)

     (let* ((new8 (get-output-u8vector p))
            (new-str (utf16->string new8 'little)))
       (check new-str => str)))

   (def (test-read-utf16le-GsfInput (inp body) (str body-string))
     (input-byte-position inp 0)
     (let* ((p (open-output-u8vector))
            (go (cut read-bytes-from-input inp 1024 p))
            (u8 (let lp ((n (go)))
                  (if (zero? n) (get-output-u8vector p) (lp (go)))))
            (new-str (string-delete (cut char=? <> #\return)
                                    (utf16->string u8 'little))))
       (check new-str => str)))








   (def attachment (find-member msg "__attach_version1.0_#00000000"))

   ;; ("__substg1.0_37010102" . #<ms-oxprop #130 name: PidTagAttachDataBinary
   ;; id: "0x3701" type: PtypBinary type-id: "0x0102" area: "Message Attachment
   ;; Properties">)
   (def attachment-binary (find-member attachment "__substg1.0_37010102"))
   ;; (def body-rtf (find-member msg "__substg1.0_10090102"))

   ;; (check (ms-oxprop-name (input-ms-oxprop body-rtf))
   ;;        => 'PidTagRtfCompressed)
   ;; (check (ms-oxprop-type (input-ms-oxprop body-rtf))
   ;;        => 'PtypBinary)

   ;; All raw byte sequences are encoded by a length value followed by the specified
   ;; number of bytes. The length value is encoded as a PtypInteger32 ([MS-OXCDATA]
   ;; section 2.11.1) as shown in section 2.9.6.1. For example, the byte sequence 0x22
   ;; 0xF8 0xFF 0x00 0x22 would be encoded as 0x05 0x22 0xF8 0xFF 0x00 0x22. A zero
   ;; length PtypBinary ([MS-OXCDATA] section 2.11.1) value MUST NOT be encoded, but
   ;; MUST be marked as not present in the presenceBitArray.

   ;; (def (bytes->integer bytes)
   ;;   (let lp ((i 0) (r 0))
   ;;     (if (fx< i (u8vector-length bytes))
   ;;       (let (b (u8vector-ref bytes i))
   ;;         (lp (fx1+ i) (bitwise-ior (arithmetic-shift r 8) b)))
   ;;       r)))

   ;; (def (integer->bytes x)
   ;;   (let lp ((x x) (r []))
   ;;     (if (positive? x)
   ;;       (lp (arithmetic-shift x -8)
   ;;           (cons (bitwise-and x #xff) r))
   ;;       (list->u8vector r))))
 #+end_src

**** /File/ ~test/u8vector.ss~
 #+begin_src gerbil :tangle test/u8vector.ss :noweb yes
   (import (for-syntax :drewc/gsf/glib) :std/foreign
           :drewc/gsf/glib :std/srfi/13)
   (export read-bytes-from-input input-tell input-seek input-byte-position)

   (begin-glib-ffi (read-bytes-from-input input-tell input-seek G_SEEK_SET G_SEEK_CURR G_SEEK_END)

     (c-declare #<<END-C


   #include <gsf/gsf.h>
   #include <glib/gi18n.h>
   #include <glib/gstdio.h>
   #include <gio/gio.h>
   #include <locale.h>
   #include <string.h>
   #include <errno.h>


   END-C
   )

     <<open-archive-objects>>
     <<write_u8>>

     (c-declare #<<END-C
      <<scm_read_bytes_from_input>>

   END-C
   )
     <<input-tell-and-seek>>

     <<read-bytes-from-input>>)


   <<input-byte-position>>

 #+end_src

*** Read attachment ~GsfInput*~ to a file.

 I'm fairly certain that when this is done I can go to intermission and get a
 byte to eat.

 So, it turns out that properties are not actually stored in *streams*, which
 are actually files with names, but rather in a ~__properties_version1.0~
 *stream*

 Yet, "Each variable length property has an entry in the property stream.
 However, the entry contains only the property tag, a flag providing more
 information about the property, the size, and a reserved field. The entry does
 not contain the variable length property's value. Since the value can be
 variable in length, it is stored in an individual stream by
 itself."[fn:ms-oxmsg-var-props], so my initial thoughts are not that far off.

 So, apparently ~"__substg1.0_3707001F"~ is ~PidTagAttachLongFilename~.

*** Test
 #+begin_src gerbil
   (import :drewc/gsf/test/find-member
           :drewc/gsf/test/open-archive
           :drewc/gsf/test/iconv
           :drewc/gsf/test/ms-oxprop-db
           :drewc/gsf/test/list-children
           :drewc/gsf/test/substg-string
           :drewc/gsf/test/u8vector
           :drewc/gsf/test/input-to-string
           :std/test

           :std/srfi/13
           :std/text/utf16
           )

   (def msg (open-archive "/home/user/src/gerbil-gsf/test/Outlook1.msg"))


   (def attachment (find-member msg "__attach_version1.0_#00000000"))

   ;; ("__substg1.0_3707001F" .
   ;;  #<ms-oxprop #82
   ;;  name: PidTagAttachLongFilename id: "0x3707" type: PtypString
   ;;  type-id: "0x001F" area: "Message Attachment Properties">)

   (def attachment-filename-input-name  "__substg1.0_3707001F")
   (def attachment-filename-input (find-member attachment "__substg1.0_3707001F"))
   (def attachment-filename (substg->string attachment-filename-input))

   ;; ("__substg1.0_37010102" . #<ms-oxprop #130 name: PidTagAttachDataBinary
   ;; id: "0x3701" type: PtypBinary type-id: "0x0102" area: "Message Attachment
   ;; Properties">)

   (def attachment-binary-input-name "__substg1.0_37010102")
   (def attachment-binary (find-member attachment "__substg1.0_37010102"))

   (check (ms-oxprop-name (input-ms-oxprop attachment-binary))
          => 'PidTagAttachDataBinary)
   (check (ms-oxprop-type (input-ms-oxprop attachment-binary))
         => 'PtypBinary)

   (def (attachment->file (attachment attachment)
                          dir: (dir "/home/user/src/gerbil-gsf/test"))
     (let* ((fn (substg->string
                 (find-member attachment attachment-filename-input-name)))
            (bin (find-member attachment attachment-binary-input-name))
            (get (cut read-bytes-from-input bin 1024 <>))
            (path (path-expand fn dir)))
       (input-byte-position bin 0)
       (call-with-output-file
        path
        (lambda (port)
          (let lp ((bytes (get port)))
            (if (zero? bytes) path (lp (get port))))))))

   (def attachment-filesystem-path (attachment->file attachment))

   ;; ("__substg1.0_370E001F" . #<ms-oxprop #83 name: PidTagAttachMimeTag
   ;; id: "0x370E" type: PtypString type-id: "0x001F"
   ;; area: "Message Attachment Properties">)


   (def (file-mime-type path)
     (string-trim-right
      (cdr (shell-command
            (string-append "file -b0 --mime-type " path) #t))
      #\newline))

   (def attachment-file-mime-type
     (file-mime-type attachment-filesystem-path))


   (def attachment-mime-input-name "__substg1.0_370E001F")
   (def attachment-mime-type (substg->string (find-member attachment attachment-mime-input-name)))

   (check attachment-file-mime-type => attachment-mime-type)











   ;; All raw byte sequences are encoded by a length value followed by the specified
   ;; number of bytes. The length value is encoded as a PtypInteger32 ([MS-OXCDATA]
   ;; section 2.11.1) as shown in section 2.9.6.1. For example, the byte sequence 0x22
   ;; 0xF8 0xFF 0x00 0x22 would be encoded as 0x05 0x22 0xF8 0xFF 0x00 0x22. A zero
   ;; length PtypBinary ([MS-OXCDATA] section 2.11.1) value MUST NOT be encoded, but
   ;; MUST be marked as not present in the presenceBitArray.

   ;; (def (bytes->integer bytes)
   ;;    (let lp ((i 0) (r 0))
   ;;    (if (fx< i (u8vector-length bytes))
   ;;        (let (b (u8vector-ref bytes i))
   ;;          (lp (fx1+ i) (bitwise-ior (arithmetic-shift r 8) b)))
   ;;        r)))

   ;; (def (integer->bytes x)
   ;;   (let lp ((x x) (r []))
   ;;     (if (positive? x)
   ;;       (lp (arithmetic-shift x -8)
   ;;           (cons (bitwise-and x #xff) r))
   ;;       (list->u8vector r))))
 #+end_src
    
**** /File/ ~test/attachment.ss~
 #+begin_src gerbil :tangle test/u8vector.ss :noweb yes
   (import (for-syntax :drewc/gsf/glib) :std/foreign
           :drewc/gsf/glib :std/srfi/13)
   (export read-bytes-from-input input-tell input-seek input-byte-position)

   (begin-glib-ffi (read-bytes-from-input input-tell input-seek G_SEEK_SET G_SEEK_CURR G_SEEK_END)

     (c-declare #<<END-C


   #include <gsf/gsf.h>
   #include <glib/gi18n.h>
   #include <glib/gstdio.h>
   #include <gio/gio.h>
   #include <locale.h>
   #include <string.h>
   #include <errno.h>


   END-C
   )

     <<open-archive-objects>>
     <<write_u8>>

     (c-declare #<<END-C
      <<scm_read_bytes_from_input>>

   END-C
   )
     <<input-tell-and-seek>>

     <<read-bytes-from-input>>)


   <<input-byte-position>>

 #+end_src

** /File ~gsf.c~
   :PROPERTIES:
   :CUSTOM_ID: gsf_c
   :END:

#+begin_src c

  /* vim: set sw=8: -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */

  #include <gsf-config.h>
  #include <gsf/gsf.h>
  #include <glib/gi18n.h>
  #include <glib/gstdio.h>
  #include <gio/gio.h>
  #include <locale.h>
  #include <string.h>
  #include <errno.h>

  static gboolean show_version;
  static int opt_zip64 = -1;

  static GOptionEntry const gsf_options [] = {
    {
      "version", 'v',
      0, G_OPTION_ARG_NONE, &show_version,
      N_("Display program version"),
      NULL
    },

    /* All options below are for gsf testing only.  */
    {
      "zip64", 0,
      G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_INT, &opt_zip64,
      "",
      NULL
    },

    /* ---------------------------------------- */

    { NULL, 0, 0, 0, NULL, NULL, NULL}
  };

  /* ------------------------------------------------------------------------- */

  static GsfInfile *
  open_archive (char const *filename)
  {
    GsfInfile *infile;
    GError *error = NULL;
    GsfInput *src;
    char *display_name;

    src = gsf_input_stdio_new (filename, &error);
    if (error) {
      display_name = g_filename_display_name (filename);
      g_printerr (_("%s: Failed to open %s: %s\n"),
            g_get_prgname (),
            display_name,
            error->message);
      g_free (display_name);
      return NULL;
    }

    infile = gsf_infile_zip_new (src, NULL);
    if (infile) {
      g_object_unref (src);
      return infile;
    }

    infile = gsf_infile_msole_new (src, NULL);
    if (infile) {
      g_object_unref (src);
      return infile;
    }

    infile = gsf_infile_tar_new (src, NULL);
    if (infile) {
      g_object_unref (src);
      return infile;
    }

    display_name = g_filename_display_name (filename);
    g_printerr (_("%s: Failed to recognize %s as an archive\n"),
          g_get_prgname (),
          display_name);
    g_free (display_name);

    g_object_unref (src);
    return NULL;
  }

  /* ------------------------------------------------------------------------- */

  static GsfInput *
  find_member (GsfInfile *arch, char const *name)
  {
    char const *slash = strchr (name, '/');

    if (slash) {
      char *dirname = g_strndup (name, slash - name);
      GsfInput *member;
      GsfInfile *dir;

      member = gsf_infile_child_by_name (arch, dirname);
      g_free (dirname);
      if (!member)
        return NULL;
      dir = GSF_INFILE (member);
      member = find_member (dir, slash + 1);
      g_object_unref (dir);
      return member;
    } else {
      return gsf_infile_child_by_name (arch, name);
    }
  }

  /* ------------------------------------------------------------------------- */

  static int
  gsf_help (G_GNUC_UNUSED int argc, G_GNUC_UNUSED char **argv)
  {
    g_print (_("Available subcommands are...\n"));
    g_print (_("* cat        output one or more files in archive\n"));
    g_print (_("* dump       dump one or more files in archive as hex\n"));
    g_print (_("* help       list subcommands\n"));
    g_print (_("* list       list files in archive\n"));
    g_print (_("* listprops  list document properties in archive\n"));
    g_print (_("* props      print specified document properties\n"));
    g_print (_("* createole  create OLE archive\n"));
    g_print (_("* createzip  create ZIP archive\n"));
    return 0;
  }

  /* ------------------------------------------------------------------------- */

  static void
  ls_R (GsfInput *input, char const *prefix)
  {
    char const *name = gsf_input_name (input);
    GsfInfile *infile = GSF_IS_INFILE (input) ? GSF_INFILE (input) : NULL;
    gboolean is_dir = infile && gsf_infile_num_children (infile) > 0;
    char *full_name;
    char *new_prefix;
    GDateTime *modtime = gsf_input_get_modtime (input);
    char *modtxt;

    if (prefix) {
      char *display_name = name ?
        g_filename_display_name (name)
        : g_strdup ("?");
      full_name = g_strconcat (prefix,
             display_name,
             NULL);
      new_prefix = g_strconcat (full_name, "/", NULL);
      g_free (display_name);
    } else {
      full_name = g_strdup ("*root*");
      new_prefix = g_strdup ("");
    }

    modtxt = modtime
      ? g_date_time_format (modtime, "%F %H:%M:%S")
      : g_strdup ("                   ");

    g_print ("%c  %s  %10" GSF_OFF_T_FORMAT " %s\n",
       (is_dir ? 'd' : 'f'),
       modtxt,
       gsf_input_size (input),
       full_name);

    g_free (modtxt);

    if (is_dir) {
      int i;
      for (i = 0 ; i < gsf_infile_num_children (infile) ; i++) {
        GsfInput *child = gsf_infile_child_by_index (infile, i);
        /* We can get NULL here in case of file corruption.  */
        if (child) {
          ls_R (child, new_prefix);
          g_object_unref (child);
        }
      }
    }

    g_free (full_name);
    g_free (new_prefix);
  }

  static int
  gsf_list (int argc, char **argv)
  {
    int i;

    for (i = 0; i < argc; i++) {
      char const *filename = argv[i];
      char *display_name;
      GsfInfile *infile = open_archive (filename);
      if (!infile)
        return 1;

      if (i > 0)
        g_print ("\n");

      display_name = g_filename_display_name (filename);
      g_print ("%s:\n", display_name);
      g_free (display_name);

      ls_R (GSF_INPUT (infile), NULL);
      g_object_unref (infile);
    }

    return 0;
  }

  /* ------------------------------------------------------------------------- */

  static int
  gsf_dump (int argc, char **argv, gboolean hex)
  {
    char const *filename;
    GsfInfile *infile;
    int i;
    int res = 0;

    if (argc < 2)
      return 1;

    filename = argv[0];
    infile = open_archive (filename);
    if (!infile)
      return 1;

    for (i = 1; i < argc; i++) {
      char const *name = argv[i];
      GsfInput *member = find_member (infile, name);
      if (!member) {
        char *display_name = g_filename_display_name (name);
        g_print ("%s: archive has no member %s\n",
           g_get_prgname (), display_name);
        g_free (display_name);
        res = 1;
        break;
      }

      if (hex) {
        char *display_name = g_filename_display_name (name);
        g_print ("%s:\n", display_name);
        g_free (display_name);
      }
      gsf_input_dump (member, hex);
      g_object_unref (member);
    }

    g_object_unref (infile);
    return res;
  }

  static GsfDocMetaData *
  get_meta_data (GsfInfile *infile, const char *filename)
  {
    GsfDocMetaData *meta_data = gsf_doc_meta_data_new ();

    if (GSF_IS_INFILE_MSOLE (infile)) {
      GsfInput *in;
      GError *err;

      in = gsf_infile_child_by_name (infile, "\05SummaryInformation");
      if (NULL != in) {
        err = gsf_doc_meta_data_read_from_msole (meta_data, in);
        if (err != NULL) {
          g_warning ("'%s' error: %s", filename, err->message);
          g_error_free (err);
          err = NULL;
        }
        g_object_unref (G_OBJECT (in));
      }

      in = gsf_infile_child_by_name (infile, "\05DocumentSummaryInformation");
      if (NULL != in) {
        err = gsf_doc_meta_data_read_from_msole (meta_data, in);
        if (err != NULL) {
          g_warning ("'%s' error: %s", filename, err->message);
          g_error_free (err);
          err = NULL;
        }

        g_object_unref (G_OBJECT (in));
      }
    }

    return meta_data;
  }

  static int
  gsf_dump_props (int argc, char **argv)
  {
    GsfInfile *infile;
    GsfDocMetaData *meta_data;
    char const *filename;
    int res = 0;
    int i;

    if (argc < 2)
      return 1;

    filename = argv[0];
    infile = open_archive (filename);
    if (!infile)
      return 1;

    meta_data = get_meta_data (infile, filename);

    for (i = 1; i < argc; i++) {
      const char *name = argv[i];
      GsfDocProp const *prop =
        gsf_doc_meta_data_lookup (meta_data, name);
      if (prop) {
        if (argc > 2)
          g_print ("%s: ", name);
        gsf_doc_prop_dump (prop);
      } else {
        g_printerr (_("No property named %s\n"), name);
      }
    }

    g_object_unref (meta_data);
    g_object_unref (infile);
    return res;
  }

  static void
  cb_collect_names (gpointer key,
        G_GNUC_UNUSED gpointer value,
        gpointer user)
  {
    const char *name = key;
    GSList **names = user;

    ,*names = g_slist_prepend (*names, g_strdup (name));
  }

  static void
  cb_print_names (const char *name)
  {
    g_print ("%s\n", name);
  }

  static int
  gsf_list_props (int argc, char **argv)
  {
    GsfInfile *infile;
    GsfDocMetaData *meta_data;
    char const *filename;
    GSList *names = NULL;

    if (argc != 1)
      return 1;

    filename = argv[0];
    infile = open_archive (filename);
    if (!infile)
      return 1;

    meta_data = get_meta_data (infile, filename);
    gsf_doc_meta_data_foreach (meta_data, cb_collect_names, &names);
    names = g_slist_sort (names, (GCompareFunc)strcmp);
    g_slist_foreach (names, (GFunc)cb_print_names, NULL);
    g_slist_free (names);

    g_object_unref (meta_data);
    g_object_unref (infile);
    return 0;
  }

  /* ------------------------------------------------------------------------- */

  static void
  show_error (char const *name, GError *error)
  {
    char *display_name;
    display_name = g_filename_display_name (name);
    g_printerr (_("%s: Error processing file %s: %s\n"),
          g_get_prgname (),
          display_name,
          error->message);
    g_free (display_name);
  }

  /* Walks "path" directory structure while loading it in "outfile" */
  static void
  load_recursively (GsfOutfile *outfile, char const *path)
  {
    GError *error = NULL;
    GStatBuf statbuf;

    if (g_stat (path, &statbuf) == -1) {
      g_printerr ("Failed to stat %s: %s\n",
            path, g_strerror (errno));
      return;
    }

    if (S_ISDIR (statbuf.st_mode)) {
      GsfInfile *in = gsf_infile_stdio_new (path, &error);
      GsfOutfile *out;
      int i, n;
      char *base;

      if (!in) {
        show_error (path, error);
        return;
      }

      base = g_path_get_basename (path);
      out = GSF_OUTFILE (gsf_outfile_new_child (outfile, base, TRUE));
      g_free (base);

      n = gsf_infile_num_children (in);
      for (i = 0; i < n; i++) {
        char const *child = gsf_infile_name_by_index (in, i);
        char *name = g_build_filename (path, child, NULL);
        load_recursively (out, name);
        g_free (name);
      }

      g_object_unref (out);
      g_object_unref (in);
    } else if (S_ISREG (statbuf.st_mode)) {
      char *base;
      GsfInput *in;
      GsfOutput *out;
      gboolean ok;

      in = gsf_input_stdio_new (path, &error);
      if (!in) {
        show_error (path, error);
        return;
      }

      base = g_path_get_basename (path);
      out = gsf_outfile_new_child_full
        (outfile, base, FALSE,
         "modtime", gsf_input_get_modtime (in),
         NULL);
      g_printerr ("Adding %s\n", path);

      ok = gsf_input_copy (in, out);
      if (!ok)
        g_printerr ("Error in adding member.\n");

      ok = gsf_output_close (out);
      if (!ok)
        g_printerr ("Error in adding member (at close)\n");

      g_object_unref (out);
      g_free (base);


      g_object_unref (in);
    } else {
      g_printerr ("Ignoring %s\n", path);
    }
  }

  static int
  gsf_create (int argc, char **argv, GType type)
  {
    char const *filename;
    GError *error = NULL;
    GsfOutput *dest;
    GsfOutfile *outfile;
    int i;
    gboolean ok;

    if (argc < 2)
      return 1;

    filename = argv[0];
    if (strcmp (filename, "-") == 0)
      dest = gsf_output_stdio_new_FILE (filename, stdout, TRUE);
    else
      dest = gsf_output_stdio_new (filename, &error);
    if (error) {
      show_error (filename, error);
      return 1;
    }

    if (type == GSF_OUTFILE_MSOLE_TYPE)
      outfile = gsf_outfile_msole_new (dest);
    else if (type == GSF_OUTFILE_ZIP_TYPE) {
      outfile = g_object_new (GSF_OUTFILE_ZIP_TYPE,
            "sink", dest,
            "zip64", opt_zip64,
            NULL);
    } else
      g_assert_not_reached ();

    if (error) {
      show_error (filename, error);
      return 1;
    }

    for (i = 1; i < argc; i++) {
      GFile *file = g_file_new_for_commandline_arg (argv[i]);
      char *path = g_file_get_path (file);
      load_recursively (outfile, path);
      g_free (path);
      g_object_unref (file);
    }

    ok = gsf_output_close (GSF_OUTPUT (outfile));
    if (!ok)
      g_printerr ("Error while closing archive\n");

    g_object_unref (dest);
    g_object_unref (outfile);
    return 0;
  }

  /* ------------------------------------------------------------------------- */

  int
  main (int argc, char **argv)
  {
    GOptionContext *ocontext;
    GError *error = NULL;
    char const *usage;
    char const *cmd;
    char const *me = (argv[0] ? argv[0] : "gsf");

    g_set_prgname (me);
    gsf_init ();

    bindtextdomain (GETTEXT_PACKAGE, GSFLOCALEDIR);
    textdomain (GETTEXT_PACKAGE);
    setlocale (LC_ALL, "");

    usage = _("SUBCOMMAND ARCHIVE...");
    ocontext = g_option_context_new (usage);
    g_option_context_add_main_entries (ocontext, gsf_options, GETTEXT_PACKAGE);
    g_option_context_parse (ocontext, &argc, &argv, &error);
    g_option_context_free (ocontext);

    if (error) {
      g_printerr (_("%s\nRun '%s --help' to see a full list of available command line options.\n"),
            error->message, me);
      g_error_free (error);
      return 1;
    }

    if (show_version) {
      g_print (_("gsf version %d.%d.%d\n"),
         libgsf_major_version, libgsf_minor_version, libgsf_micro_version);
      return 0;
    }

    if (argc <= 1) {
      g_printerr (_("Usage: %s %s\n"), me, usage);
      return 1;
    }

    cmd = argv[1];

    if (strcmp (cmd, "help") == 0)
      return gsf_help (argc - 2, argv + 2);

    if (strcmp (cmd, "list") == 0 || strcmp (cmd, "l") == 0)
      return gsf_list (argc - 2, argv + 2);

    if (strcmp (cmd, "cat") == 0)
      return gsf_dump (argc - 2, argv + 2, FALSE);
    if (strcmp (cmd, "dump") == 0)
      return gsf_dump (argc - 2, argv + 2, TRUE);
    if (strcmp (cmd, "props") == 0)
      return gsf_dump_props (argc - 2, argv + 2);
    if (strcmp (cmd, "listprops") == 0)
      return gsf_list_props (argc - 2, argv + 2);
    if (strcmp (cmd, "createole") == 0)
      return gsf_create (argc - 2, argv + 2, GSF_OUTFILE_MSOLE_TYPE);
    if (strcmp (cmd, "createzip") == 0)
      return gsf_create (argc - 2, argv + 2, GSF_OUTFILE_ZIP_TYPE);

    g_printerr (_("Run '%s help' to see a list of subcommands.\n"), me);
    return 1;
  }
#+end_src


** ~man gsf~

#+begin_src shell :results output
man gsf
#+end_src

#+begin_example
GSF(1)                               GNOME                              GSF(1)

NAME
       gsf - archiving utility using the G Structured File library

SYNOPSIS
       gsf [OPTION...] SUBCOMMAND ARCHIVE...

DESCRIPTION
       This manual page briefly documents the gsf command.

       gsf  is  a simple archive utility, somewhat similar to tar(1). It oper‐
       ates on files following one of the structured file  formats  understood
       by  the  G  Structured  File  library, for example, Microsoft Excel(TM)
       files.

OPTIONS
   Options
       -?, --help
              Show help options

       -v, --version
              Display gsf's version

   Subcommands
       cat    Output one or more files in archive

       dump   Dump one or more files in archive as formatted hexadecimal

       help   List subcommands

       list   List files in archive

       props  Archive list of property names

EXAMPLES
       To list the content structure of a Microsoft Excel(TM) file arrays.xls:

       gsf list arrays.xls

       To dump Workbook, an individual data stream in arrays.xls:

       gsf dump arrays.xls Workbook

AUTHORS
       gsf's primary authors are Morten Welinder  <terra@gnome.org>  and  Jody
       Goldberg <jody@gnome.org>.

       The  initial version of this manpage was written by J.H.M. Dassen (Ray)
       <jdassen@debian.org>.

SEE ALSO
       gnumeric(1)

       The Gnumeric homepage ⟨http://www.gnome.org/projects/gnumeric/⟩

       The GNOME project page ⟨http://www.gnome.org/⟩

gsf                            29 November 2009                         GSF(1)
#+end_example

** /File/ ~msg.reader.js~
   :PROPERTIES:
   :CUSTOM_ID: msg_reader_js
   :END:


#+begin_src javascript
  /* Copyright 2016 Yury Karpovich
   ,*
   ,* Licensed under the Apache License, Version 2.0 (the "License");
   ,* you may not use this file except in compliance with the License.
   ,* You may obtain a copy of the License at
   ,*
   ,*     http://www.apache.org/licenses/LICENSE-2.0
   ,*
   ,* Unless required by applicable law or agreed to in writing, software
   ,* distributed under the License is distributed on an "AS IS" BASIS,
   ,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   ,* See the License for the specific language governing permissions and
   ,* limitations under the License.
   ,*/
  /*
   MSG Reader
   ,*/

  (function () {

    // constants
    var CONST = {
      FILE_HEADER: uInt2int([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),
      MSG: {
        UNUSED_BLOCK: -1,
        END_OF_CHAIN: -2,

        S_BIG_BLOCK_SIZE: 0x0200,
        S_BIG_BLOCK_MARK: 9,

        L_BIG_BLOCK_SIZE: 0x1000,
        L_BIG_BLOCK_MARK: 12,

        SMALL_BLOCK_SIZE: 0x0040,
        BIG_BLOCK_MIN_DOC_SIZE: 0x1000,
        HEADER: {
          PROPERTY_START_OFFSET: 0x30,

          BAT_START_OFFSET: 0x4c,
          BAT_COUNT_OFFSET: 0x2C,

          SBAT_START_OFFSET: 0x3C,
          SBAT_COUNT_OFFSET: 0x40,

          XBAT_START_OFFSET: 0x44,
          XBAT_COUNT_OFFSET: 0x48
        },
        PROP: {
          NO_INDEX: -1,
          PROPERTY_SIZE: 0x0080,

          NAME_SIZE_OFFSET: 0x40,
          MAX_NAME_LENGTH: (/*NAME_SIZE_OFFSET*/0x40 / 2) - 1,
          TYPE_OFFSET: 0x42,
          PREVIOUS_PROPERTY_OFFSET: 0x44,
          NEXT_PROPERTY_OFFSET: 0x48,
          CHILD_PROPERTY_OFFSET: 0x4C,
          START_BLOCK_OFFSET: 0x74,
          SIZE_OFFSET: 0x78,
          TYPE_ENUM: {
            DIRECTORY: 1,
            DOCUMENT: 2,
            ROOT: 5
          }
        },
        FIELD: {
          PREFIX: {
            ATTACHMENT: '__attach_version1.0',
            RECIPIENT: '__recip_version1.0',
            DOCUMENT: '__substg1.'
          },
          // example (use fields as needed)
          NAME_MAPPING: {
            // email specific
            '0037': 'subject',
            '0c1a': 'senderName',
            '5d02': 'senderEmail',
            '1000': 'body',
            '1013': 'bodyHTML',
            '007d': 'headers',
            // attachment specific
            '3703': 'extension',
            '3704': 'fileNameShort',
            '3707': 'fileName',
            '3712': 'pidContentId',
            '370e': 'mimeType',
            // recipient specific
            '3001': 'name',
            '39fe': 'email'
          },
          CLASS_MAPPING: {
            ATTACHMENT_DATA: '3701'
          },
          TYPE_MAPPING: {
            '001e': 'string',
            '001f': 'unicode',
            '0102': 'binary'
          },
          DIR_TYPE: {
            INNER_MSG: '000d'
          }
        }
      }
    };

    // unit utils
    function arraysEqual(a, b) {
      if (a === b) return true;
      if (a == null || b == null) return false;
      if (a.length != b.length) return false;

      for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    function uInt2int(data) {
      var result = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        result[i] = data[i] << 24 >> 24;
      }
      return result;
    }

    // MSG Reader implementation

    // check MSG file header
    function isMSGFile(ds) {
      ds.seek(0);
      return arraysEqual(CONST.FILE_HEADER, ds.readInt8Array(CONST.FILE_HEADER.length));
    }

    // FAT utils
    function getBlockOffsetAt(msgData, offset) {
      return (offset + 1) * msgData.bigBlockSize;
    }

    function getBlockAt(ds, msgData, offset) {
      var startOffset = getBlockOffsetAt(msgData, offset);
      ds.seek(startOffset);
      return ds.readInt32Array(msgData.bigBlockLength);
    }

    function getNextBlockInner(ds, msgData, offset, blockOffsetData) {
      var currentBlock = Math.floor(offset / msgData.bigBlockLength);
      var currentBlockIndex = offset % msgData.bigBlockLength;

      var startBlockOffset = blockOffsetData[currentBlock];

      return getBlockAt(ds, msgData, startBlockOffset)[currentBlockIndex];
    }

    function getNextBlock(ds, msgData, offset) {
      return getNextBlockInner(ds, msgData, offset, msgData.batData);
    }

    function getNextBlockSmall(ds, msgData, offset) {
      return getNextBlockInner(ds, msgData, offset, msgData.sbatData);
    }

    // convert binary data to dictionary
    function parseMsgData(ds) {
      var msgData = headerData(ds);
      msgData.batData = batData(ds, msgData);
      msgData.sbatData = sbatData(ds, msgData);
      if (msgData.xbatCount > 0) {
        xbatData(ds, msgData);
      }
      msgData.propertyData = propertyData(ds, msgData);
      msgData.fieldsData = fieldsData(ds, msgData);

      return msgData;
    }

    // extract header data
    function headerData(ds) {
      var headerData = {};

      // system data
      headerData.bigBlockSize =
        ds.readByte(/*const position*/30) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;
      headerData.bigBlockLength = headerData.bigBlockSize / 4;
      headerData.xBlockLength = headerData.bigBlockLength - 1;

      // header data
      headerData.batCount = ds.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);
      headerData.propertyStart = ds.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);
      headerData.sbatStart = ds.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);
      headerData.sbatCount = ds.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);
      headerData.xbatStart = ds.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);
      headerData.xbatCount = ds.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);

      return headerData;
    }

    function batCountInHeader(msgData) {
      var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;
      return Math.min(msgData.batCount, maxBatsInHeader);
    }

    function batData(ds, msgData) {
      var result = new Array(batCountInHeader(msgData));
      ds.seek(CONST.MSG.HEADER.BAT_START_OFFSET);
      for (var i = 0; i < result.length; i++) {
        result[i] = ds.readInt32()
      }
      return result;
    }

    function sbatData(ds, msgData) {
      var result = [];
      var startIndex = msgData.sbatStart;

      for (var i = 0; i < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i++) {
        result.push(startIndex);
        startIndex = getNextBlock(ds, msgData, startIndex);
      }
      return result;
    }

    function xbatData(ds, msgData) {
      var batCount = batCountInHeader(msgData);
      var batCountTotal = msgData.batCount;
      var remainingBlocks = batCountTotal - batCount;

      var nextBlockAt = msgData.xbatStart;
      for (var i = 0; i < msgData.xbatCount; i++) {
        var xBatBlock = getBlockAt(ds, msgData, nextBlockAt);
        nextBlockAt = xBatBlock[msgData.xBlockLength];

        var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);
        for (var j = 0; j < blocksToProcess; j++) {
          var blockStartAt = xBatBlock[j];
          if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {
            break;
          }
          msgData.batData.push(blockStartAt);
        }
        remainingBlocks -= blocksToProcess;
      }
    }

    // extract property data and property hierarchy
    function propertyData(ds, msgData) {
      var props = [];

      var currentOffset = msgData.propertyStart;

      while (currentOffset != CONST.MSG.END_OF_CHAIN) {
        convertBlockToProperties(ds, msgData, currentOffset, props);
        currentOffset = getNextBlock(ds, msgData, currentOffset);
      }
      createPropertyHierarchy(props, /*property with index 0 (zero) always as root*/props[0]);
      return props;
    }

    function convertName(ds, offset) {
      var nameLength = ds.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);
      if (nameLength < 1) {
        return '';
      } else {
        return ds.readStringAt(offset, nameLength / 2);
      }
    }

    function convertProperty(ds, index, offset) {
      return {
        index: index,
        type: ds.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),
        name: convertName(ds, offset),
        // hierarchy
        previousProperty: ds.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),
        nextProperty: ds.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),
        childProperty: ds.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),
        // data offset
        startBlock: ds.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),
        sizeBlock: ds.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)
      };
    }

    function convertBlockToProperties(ds, msgData, propertyBlockOffset, props) {

      var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;
      var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);

      for (var i = 0; i < propertyCount; i++) {
        var propertyType = ds.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);
        switch (propertyType) {
          case CONST.MSG.PROP.TYPE_ENUM.ROOT:
          case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:
          case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:
            props.push(convertProperty(ds, props.length, propertyOffset));
            break;
          default:
            /* unknown property types */
            props.push(null);
        }

        propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;
      }
    }

    function createPropertyHierarchy(props, nodeProperty) {

      if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {
        return;
      }
      nodeProperty.children = [];

      var children = [nodeProperty.childProperty];
      while (children.length != 0) {
        var currentIndex = children.shift();
        var current = props[currentIndex];
        if (current == null) {
          continue;
        }
        nodeProperty.children.push(currentIndex);

        if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {
          createPropertyHierarchy(props, current);
        }
        if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {
          children.push(current.previousProperty);
        }
        if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {
          children.push(current.nextProperty);
        }
      }
    }

    // extract real fields
    function fieldsData(ds, msgData) {
      var fields = {
        attachments: [],
        recipients: []
      };
      fieldsDataDir(ds, msgData, msgData.propertyData[0], fields);
      return fields;
    }

    function fieldsDataDir(ds, msgData, dirProperty, fields) {

      if (dirProperty.children && dirProperty.children.length > 0) {
        for (var i = 0; i < dirProperty.children.length; i++) {
          var childProperty = msgData.propertyData[dirProperty.children[i]];

          if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {
            fieldsDataDirInner(ds, msgData, childProperty, fields)
          } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT
            && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {
            fieldsDataDocument(ds, msgData, childProperty, fields);
          }
        }
      }
    }

    function fieldsDataDirInner(ds, msgData, dirProperty, fields) {
      if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {

        // attachment
        var attachmentField = {};
        fields.attachments.push(attachmentField);
        fieldsDataDir(ds, msgData, dirProperty, attachmentField);
      } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {

        // recipient
        var recipientField = {};
        fields.recipients.push(recipientField);
        fieldsDataDir(ds, msgData, dirProperty, recipientField);
      } else {

        // other dir
        var childFieldType = getFieldType(dirProperty);
        if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {
          fieldsDataDir(ds, msgData, dirProperty, fields);
        } else {
          // MSG as attachment currently isn't supported
          fields.innerMsgContent = true;
        }
      }
    }

    function isAddPropertyValue(fieldName, fieldTypeMapped) {
      return fieldName !== 'body' || fieldTypeMapped !== 'binary';
    }

    function fieldsDataDocument(ds, msgData, documentProperty, fields) {
      var value = documentProperty.name.substring(12).toLowerCase();
      var fieldClass = value.substring(0, 4);
      var fieldType = value.substring(4, 8);

      var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];
      var fieldTypeMapped = CONST.MSG.FIELD.TYPE_MAPPING[fieldType];

      if (fieldName) {
        var fieldValue = getFieldValue(ds, msgData, documentProperty, fieldTypeMapped);

        if (isAddPropertyValue(fieldName, fieldTypeMapped)) {
          fields[fieldName] = applyValueConverter(fieldName, fieldTypeMapped, fieldValue);
        }
      }
      if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {

        // attachment specific info
        fields['dataId'] = documentProperty.index;
        fields['contentLength'] = documentProperty.sizeBlock;
      }
    }

    // todo: html body test
    function applyValueConverter(fieldName, fieldTypeMapped, fieldValue) {
      if (fieldTypeMapped === 'binary' && fieldName === 'bodyHTML') {
        return convertUint8ArrayToString(fieldValue);
      }
      return fieldValue
    }

    function getFieldType(fieldProperty) {
      var value = fieldProperty.name.substring(12).toLowerCase();
      return value.substring(4, 8);
    }

    // extractor structure to manage bat/sbat block types and different data types
    var extractorFieldValue = {
      sbat: {
        'extractor': function extractDataViaSbat(ds, msgData, fieldProperty, dataTypeExtractor) {
          var chain = getChainByBlockSmall(ds, msgData, fieldProperty);
          if (chain.length == 1) {
            return readDataByBlockSmall(ds, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);
          } else if (chain.length > 1) {
            return readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor);
          }
          return null;
        },
        dataType: {
          'string': function extractBatString(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {
            ds.seek(blockStartOffset + bigBlockOffset);
            return ds.readString(blockSize);
          },
          'unicode': function extractBatUnicode(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {
            ds.seek(blockStartOffset + bigBlockOffset);
            return ds.readUCS2String(blockSize / 2);
          },
          'binary': function extractBatBinary(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {
            ds.seek(blockStartOffset + bigBlockOffset);
            return ds.readUint8Array(blockSize);
          }
        }
      },
      bat: {
        'extractor': function extractDataViaBat(ds, msgData, fieldProperty, dataTypeExtractor) {
          var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);
          ds.seek(offset);
          return dataTypeExtractor(ds, fieldProperty);
        },
        dataType: {
          'string': function extractSbatString(ds, fieldProperty) {
            return ds.readString(fieldProperty.sizeBlock);
          },
          'unicode': function extractSbatUnicode(ds, fieldProperty) {
            return ds.readUCS2String(fieldProperty.sizeBlock / 2);
          },
          'binary': function extractSbatBinary(ds, fieldProperty) {
            return ds.readUint8Array(fieldProperty.sizeBlock);
          }
        }
      }
    };

    function readDataByBlockSmall(ds, msgData, startBlock, blockSize, dataTypeExtractor) {
      var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;
      var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);
      var bigBlockOffset = byteOffset % msgData.bigBlockSize;

      var rootProp = msgData.propertyData[0];

      var nextBlock = rootProp.startBlock;
      for (var i = 0; i < bigBlockNumber; i++) {
        nextBlock = getNextBlock(ds, msgData, nextBlock);
      }
      var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);

      return dataTypeExtractor(ds, msgData, blockStartOffset, bigBlockOffset, blockSize);
    }

    function readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor) {
      var resultData = new Int8Array(fieldProperty.sizeBlock);

      for (var i = 0, idx = 0; i < chain.length; i++) {
        var data = readDataByBlockSmall(ds, msgData, chain[i], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);
        for (var j = 0; j < data.length; j++) {
          resultData[idx++] = data[j];
        }
      }
      var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);
      return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);
    }

    function getChainByBlockSmall(ds, msgData, fieldProperty) {
      var blockChain = [];
      var nextBlockSmall = fieldProperty.startBlock;
      while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {
        blockChain.push(nextBlockSmall);
        nextBlockSmall = getNextBlockSmall(ds, msgData, nextBlockSmall);
      }
      return blockChain;
    }

    function getFieldValue(ds, msgData, fieldProperty, typeMapped) {
      var value = null;

      var valueExtractor =
        fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;
      var dataTypeExtractor = valueExtractor.dataType[typeMapped];

      if (dataTypeExtractor) {
        value = valueExtractor.extractor(ds, msgData, fieldProperty, dataTypeExtractor);
      }
      return value;
    }

    function convertUint8ArrayToString(uint8ArraValue) {
      return new TextDecoder("utf-8").decode(uint8ArraValue);
    }

    // MSG Reader
    var MSGReader = function (arrayBuffer) {
      this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);
    };

    MSGReader.prototype = {
      /**
       Converts bytes to fields information
       @return {Object} The fields data for MSG file
       ,*/
      getFileData: function () {
        if (!isMSGFile(this.ds)) {
          return {error: 'Unsupported file type!'};
        }
        if (this.fileData == null) {
          this.fileData = parseMsgData(this.ds);
        }
        return this.fileData.fieldsData;
      },
      /**
       Reads an attachment content by key/ID
       @return {Object} The attachment for specific attachment key
       ,*/
      getAttachment: function (attach) {
        var attachData = typeof attach === 'number' ? this.fileData.fieldsData.attachments[attach] : attach;
        var fieldProperty = this.fileData.propertyData[attachData.dataId];
        var fieldTypeMapped = CONST.MSG.FIELD.TYPE_MAPPING[getFieldType(fieldProperty)];
        var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, fieldTypeMapped);

        return {fileName: attachData.fileName, content: fieldData};
      }
    };

    window.MSGReader = MSGReader;

  })();
#+end_src
** /File/ ~test-dump-msole.c~
   :PROPERTIES:
   :CUSTOM_ID: file_test_dump_msole_c
   :END:

 #+begin_src c :tangle test/test-dump-msole.c :mkdir yes
   /* vim: set sw=8: -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
   /*
    ,* test-dump-msole.c: Export a msole file to a directory tree
    ,*
    ,* Copyright (C) 2002-2006	Jody Goldberg (jody@gnome.org)
    ,*
    ,* This program is free software; you can redistribute it and/or
    ,* modify it under the terms of version 2.1 of the GNU Lesser General Public
    ,* License as published by the Free Software Foundation.
    ,*
    ,* This program is distributed in the hope that it will be useful,
    ,* but WITHOUT ANY WARRANTY; without even the implied warranty of
    ,* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ,* GNU General Public License for more details.
    ,*
    ,* You should have received a copy of the GNU Lesser General Public License
    ,* along with this program; if not, write to the Free Software
    ,* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
    ,* USA
    ,*/

   #include <gsf/gsf-utils.h>

   #include <gsf/gsf-input-stdio.h>
   #include <gsf/gsf-infile.h>
   #include <gsf/gsf-infile-msole.h>

   #include <gsf/gsf-output-stdio.h>
   #include <gsf/gsf-outfile.h>
   #include <gsf/gsf-outfile-stdio.h>

   #include <stdio.h>

   static void
   clone_ (GsfInput *input, GsfOutput *output)
   {
     guint8 const *data;
     size_t len;
     int i;

     if (gsf_input_size (input) > 0) {
       while ((len = gsf_input_remaining (input)) > 0) {
         /* copy in odd sized chunks to exercise system */
         if (len > 314)
           len = 314;
         if (NULL == (data = gsf_input_read (input, len, NULL))) {
           g_warning ("error reading ?");
           return;
         }
         if (!gsf_output_write (output, len, data)) {
           g_warning ("error writing ?");
           return;
         }
       }
     }

     /* See test-cp-msole.c for explanation how to distinct directories
      ,* from regular files.
      ,*/
     if (GSF_IS_INFILE (input) &&
         gsf_infile_num_children (GSF_INFILE (input)) > 0) {
       GsfInfile *in = GSF_INFILE (input);
       GsfOutfile *out = GSF_OUTFILE (output);
       GsfInput *src;
       GsfOutput *dst;
       gboolean is_dir;

       for (i = 0 ; i < gsf_infile_num_children (in) ; i++) {
         src = gsf_infile_child_by_index (in, i);
         is_dir = GSF_IS_INFILE (src) &&
           gsf_infile_num_children (GSF_INFILE (src)) >= 0;
         dst = gsf_outfile_new_child  (out,
           gsf_infile_name_by_index  (in, i),
           is_dir);
         clone_ (src, dst);
       }
     }

     gsf_output_close (output);
     g_object_unref (G_OBJECT (output));
     g_object_unref (G_OBJECT (input));
   }

   static int
   test (char *argv[])
   {
     GsfInput   *input;
     GsfInfile  *infile;
     GsfOutfile *outfile;
     GError    *err = NULL;

     fprintf (stderr, "%s\n", argv [1]);
     input = gsf_input_stdio_new (argv[1], &err);
     if (input == NULL) {
       g_return_val_if_fail (err != NULL, 1);

       g_warning ("'%s' error: %s", argv[1], err->message);
       g_error_free (err);
       return 1;
     }

     infile = gsf_infile_msole_new (input, &err);
     g_object_unref (G_OBJECT (input));

     if (infile == NULL) {
       g_return_val_if_fail (err != NULL, 1);

       g_warning ("'%s' Not an OLE file: %s", argv[1], err->message);
       g_error_free (err);
       return 1;
     }

     outfile = gsf_outfile_stdio_new (argv[2], &err);
     if (outfile == NULL) {
       g_return_val_if_fail (err != NULL, 1);

       g_warning ("'%s' error: %s", argv[1], err->message);
       g_error_free (err);
       return 1;
     }
     clone_ (GSF_INPUT (infile), GSF_OUTPUT (outfile));

     return 0;
   }

   int
   main (int argc, char *argv[])
   {
     int res;

     if (argc != 3) {
       fprintf (stderr, "%s : infile outdir\n", argv [0]);
       return 1;
     }

     gsf_init ();
     res = test (argv);
     gsf_shutdown ();

     return res;
   }
#+end_src

* Intermission

That was a lot of fun. Learned a lot about Outlook files and C and glib and FFI.

Now it needs split off into two libraries: ~gerbil-gsf~ and ~gmsg~. 

I think that ~gerbil-gsf~ and many Gerbil FFI's may be better served by
c2ffi[fn:c2ffi], but for now it's manually written.

* Act 2: GSF API and Manual (Testing).

Really, the entire library should not be contained in a README.org, which is how
it currently stands. Moving [[file:api.org::#gsf_glib_object_system][~glib.h~ and ~GObject~: The GLib Object System]] to
~api.org~ is a good start.

Now, in ~doc/manual.org~ I need to document something, and having tests would be
nice as well, so I'll document turning a ~.msg~ file into a *JSON* file as
that's my ultimate aim.

** Scene 1: Storages and Streams

What gsf calls *Input*'s, Microsoft calls *object*'s, divided into *storage*'s
and *streams*.

Which is what [[file:doc/manual.org::#gsf_storages_and_streams][we'll call them.]] The manual describes them, but this play is for
the audience, not the code. So, we'll need a test of speed and memory.













* TODO _properties_version1.0
https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxmsg/f67ea816-c5d7-41de-8e5c-93248d3970d8
* Footnotes

[fn:c2ffi] https://github.com/rpav/c2ffi

[fn:ms-oxmsg-var-props]  https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxmsg/08185828-e9e9-4ef2-bcd2-f6e69c00891b

[fn:GsfInfile] https://developer.gnome.org/gsf/1.14/gsf-Infile-reading-structed-files.html

[fn:github-ms-oxprops] https://github.com/Jmcleodfoss/ms-oxprops-db

[fn:gfs_input_read] https://developer.gnome.org/gsf/1.14/gsf-Input-from-unstructured-files.html#gsf-input-read

[fn:gambc-c-lambda]  http://www.iro.umontreal.ca/~gambit/doc/gambit.html#c_002dlambda

[fn:gsf-infile]  https://developer.gnome.org/gsf/1.14/gsf-Infile-reading-structed-files.html#GsfInfile

[fn:rfc-2781]  https://tools.ietf.org/html/rfc2781

[fn:gsf-git] https://github.com/GNOME/libgsf/

[fn:gambc-types]  http://www.iro.umontreal.ca/~gambit/doc/gambit.html#mapping-of-types

[fn:MS-OXCDATA] https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxcdata/ 

[fn:MS-OXCMSG] https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxcmsg/

[fn:MS-OXPROPS] https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxprops

[fn:MS-OXMSG]  https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxmsg

[fn:MS-CFB]  https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cfb/
